# -*- coding: utf-8 -*-



"""Some functions for parsing a FIT file (specifically, a FIT file
generated by a Garmin vÃ­voactive 3) and creating a Pandas DataFrame
with the data.
From `towardsdatascience`_ blog

.. _towardsdatascience`:
   https://towardsdatascience.com/\
       parsing-fitness-tracker-data-with-python-a59e7dc17418

https://github.com/polyvertex/fitdecode
https://github.com/bunburya/fitness_tracker_data_parsing/blob/main/parse_fit.py
"""

from datetime import datetime, timedelta
from typing import Dict, Union, Optional,Tuple
# import os.path
from pathlib import Path
import gzip

import lxml.etree
import pandas as pd
import dateutil.parser as dp

import fitdecode

# The names of the columns we will use in our points DataFrame.
# For the data we will be getting from the FIT data,
# we use the same name as the field names to make it easier to parse the data.
POINTS_COLUMN_NAMES = ['latitude',
                       'longitude',
                       'lap',
                       'altitude',
                       'timestamp',
                       'heart_rate',
                       'cadence',
                       'speed']

# The names of the columns we will use in our laps DataFrame. 
LAPS_COLUMN_NAMES = ['number',
                     'start_time',
                     'total_distance',
                     'total_elapsed_time',
                     'max_speed',
                     'max_heart_rate',
                     'avg_heart_rate']

NAMESPACES = {
    'ns': 'http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2',
    'ns2': 'http://www.garmin.com/xmlschemas/UserProfile/v2',
    'ns3': 'http://www.garmin.com/xmlschemas/ActivityExtension/v2',
    'ns4': 'http://www.garmin.com/xmlschemas/ProfileExtension/v1',
    'ns5': 'http://www.garmin.com/xmlschemas/ActivityGoals/v1'
}

def get_file_info(file_name: str) -> \
                            Dict[str, Union[float, datetime, timedelta, int]]:
    """Extract data from a FIT frame representing a FileID and return
    it as a dict.
    """
    cols = ['time_created', 'manufacturer', 'product', 'serial_number', 'type']
    data: Dict[str, Union[float, datetime, timedelta, int]] = {}
    with fitdecode.FitReader(file_name) as fit_file:
        for frame in fit_file:
            if isinstance(frame, fitdecode.records.FitDataMessage):
                if frame.name == 'file_id':
                    for field in cols:
                        if frame.has_field(field):
                            data[field] = frame.get_value(field)
                    return(data)

def extract_activity_info(file_path: str) -> \
                            Dict[str, Union[float, datetime, timedelta, int]]:
    """Extract data from a FIT frame representing a session and return
    it as a dict.
    """
    cols = ['start_time',
            'timestamp',
            'sport',
            'total_distance',
            'total_elapsed_time',
            'total_timer_time',
            'total_moving_time']
    data: Dict[str, Union[float, datetime, timedelta, int]] = {}
    file_extension = ''.join(Path(file_path).suffixes)
    if file_extension == '.fit':
        with fitdecode.FitReader(file_path) as fit_file:
            for frame in fit_file:
                if isinstance(frame, fitdecode.records.FitDataMessage):
                    if frame.name == 'session':
                        for field in cols:
                            if frame.has_field(field):
                                data[field] = frame.get_value(field)
                        return(data)
    elif file_extension == '.tcx.gz':
        with gzip.open(file_path,'r') as fin:
            xml = fin.read()

def get_fit_lap_data(frame: fitdecode.records.FitDataMessage) -> \
                            Dict[str, Union[float, datetime, timedelta, int]]:
    """Extract data from a FIT frame representing a lap and return
    it as a dict.
    """
    data: Dict[str, Union[float, datetime, timedelta, int]] = {}
    for field in LAPS_COLUMN_NAMES[1:]:  # Exclude 'number' (lap number) because we don't get that
                                        # from the data but rather count it ourselves
        if frame.has_field(field):
            data[field] = frame.get_value(field)
    return data

def get_fit_point_data(frame: fitdecode.records.FitDataMessage) -> \
                    Optional[Dict[str, Union[float, int, str, datetime]]]:
    """Extract some data from an FIT frame representing a track point
    and return it as a dict.
    """
    
    data: Dict[str, Union[float, int, str, datetime]] = {}
    
    if not (frame.has_field('position_lat') and frame.has_field('position_long')):
        # Frame does not have any latitude or longitude data. We will ignore these frames in order to keep things
        # simple, as we did when parsing the TCX file.
        return None
    else:
        data['latitude'] = frame.get_value('position_lat') / ((2**32) / 360)
        data['longitude'] = frame.get_value('position_long') / ((2**32) / 360)
    
    for field in POINTS_COLUMN_NAMES[3:]:
        if frame.has_field(field):
            data[field] = frame.get_value(field)
    
    return data
    

def get_fit_dataframes(fname: str) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Takes the path to a FIT file (as a string) and returns Pandas
    DataFrames: data about the laps, and data about the individual points.
    """
    points_data = []
    laps_data = []
    lap_no = 1
    with fitdecode.FitReader(fname) as fit_file:
        for frame in fit_file:
            if isinstance(frame, fitdecode.records.FitDataMessage):
                if frame.name == 'record':
                    single_point_data = get_fit_point_data(frame)
                    if single_point_data is not None:
                        single_point_data['lap'] = lap_no
                        points_data.append(single_point_data)
                elif frame.name == 'lap':
                    single_lap_data = get_fit_lap_data(frame)
                    single_lap_data['number'] = lap_no
                    laps_data.append(single_lap_data)
                    lap_no += 1
    
    # Create DataFrames from the data we have collected.
    # If any information is missing from a particular lap or track
    # point, it will show up as a null value or "NaN" in the DataFrame.
    
    laps_df = pd.DataFrame(laps_data, columns=LAPS_COLUMN_NAMES)
    laps_df.set_index('number', inplace=True)
    points_df = pd.DataFrame(points_data, columns=POINTS_COLUMN_NAMES)
    return(laps_df, points_df)

def get_tcx_lap_data(lap: lxml.etree._Element) -> \
                        Dict[str, Union[float, datetime, timedelta, int]]:
    """Extract some data from an XML element representing a lap and
    return it as a dict.
    """
    
    data: Dict[str, Union[float, datetime, timedelta, int]] = {}
    
    # Note that because each element's attributes and text are returned
    # as strings, we need to convert those strings
    # to the appropriate datatype (datetime, float, int, etc).
    
    start_time_str = lap.attrib['StartTime']
    data['start_time'] = dp.parse(start_time_str)
    
    distance_elem = lap.find('ns:DistanceMeters', NAMESPACES)
    if distance_elem is not None:
        data['total_distance'] = float(distance_elem.text)
    
    total_time_elem = lap.find('ns:TotalTimeSeconds', NAMESPACES)
    if total_time_elem is not None:
        data['total_elapsed_time'] = timedelta(seconds=float(total_time_elem.text))
    
    max_speed_elem = lap.find('ns:MaximumSpeed', NAMESPACES)
    if max_speed_elem is not None:
        data['max_speed'] = float(max_speed_elem.text)
    
    max_hr_elem = lap.find('ns:MaximumHeartRateBpm', NAMESPACES)
    if max_hr_elem is not None:
        data['max_heart_rate'] = float(max_hr_elem.find('ns:Value', NAMESPACES).text)
    
    avg_hr_elem = lap.find('ns:AverageHeartRateBpm', NAMESPACES)
    if avg_hr_elem is not None:
        data['avg_heart_rate'] = float(avg_hr_elem.find('ns:Value', NAMESPACES).text)
    
    return data

def get_tcx_point_data(point: lxml.etree._Element) -> Optional[Dict[str, Union[float, int, str, datetime]]]:
    """Extract some data from an XML element representing a track point
    and return it as a dict.
    """
    
    data: Dict[str, Union[float, int, str, datetime]] = {}
    
    position = point.find('ns:Position', NAMESPACES)
    if position is None:
        # This Trackpoint element has no latitude or longitude data.
        # For simplicity's sake, we will ignore such points.
        return None
    else:
        data['latitude'] = float(position.find('ns:LatitudeDegrees', NAMESPACES).text)
        data['longitude'] = float(position.find('ns:LongitudeDegrees', NAMESPACES).text)
    
    time_str = point.find('ns:Time', NAMESPACES).text
    data['timestamp'] = dp.parse(time_str)
        
    elevation_elem = point.find('ns:AltitudeMeters', NAMESPACES)
    if elevation_elem is not None:
        data['altitude'] = float(elevation_elem.text)
    
    hr_elem = point.find('ns:HeartRateBpm', NAMESPACES)
    if hr_elem is not None:
        data['heart_rate'] = int(hr_elem.find('ns:Value', NAMESPACES).text)
        
    cad_elem = point.find('ns:Cadence', NAMESPACES)
    if cad_elem is not None:
        data['cadence'] = int(cad_elem.text)
    
    # The ".//" here basically tells lxml to search recursively down the tree for the relevant tag, rather than just the
    # immediate child elements of speed_elem. See https://lxml.de/tutorial.html#elementpath
    speed_elem = point.find('.//ns3:Speed', NAMESPACES)
    if speed_elem is not None:
        data['speed'] = float(speed_elem.text)
    
    return data
    

def get_tcx_dataframes(xml_string: str) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Takes the path to a TCX file (as a string) and returns two Pandas
    DataFrames: one containing data about the laps, and one containing
    data about the individual points.
    """
    
    # tree = lxml.etree.parse(fname)
    # root = tree.getroot()
    root = lxml.etree.fromstring(xml_string)
    activity = root.find('ns:Activities', NAMESPACES)[0]  # Assuming we know there is only one Activity in the TCX file
                                                          # (or we are only interested in the first one)
    points_data = []
    laps_data = []
    lap_no = 1
    for lap in activity.findall('ns:Lap', NAMESPACES):
        # Get data about the lap itself
        single_lap_data = get_tcx_lap_data(lap)
        single_lap_data['number'] = lap_no
        laps_data.append(single_lap_data)
        
        # Get data about the track points in the lap
        track = lap.find('ns:Track', NAMESPACES) 
        for point in track.findall('ns:Trackpoint', NAMESPACES):
            single_point_data = get_tcx_point_data(point)
            if single_point_data:
                single_point_data['lap'] = lap_no
                points_data.append(single_point_data)
        lap_no += 1
    
    # Create DataFrames from the data we have collected. If any information is missing from a particular lap or track
    # point, it will show up as a null value or "NaN" in the DataFrame.
    
    laps_df = pd.DataFrame(laps_data, columns=LAPS_COLUMN_NAMES)
    laps_df.set_index('number', inplace=True)
    points_df = pd.DataFrame(points_data, columns=POINTS_COLUMN_NAMES)
    
    return laps_df, points_df

if __name__ == '__main__':
    
    from sys import argv
    fname = argv[1]  # Path to FIT file to be given as first argument to script
    laps_df, points_df = get_fit_dataframes(fname)
    print('LAPS:')
    print(laps_df)
    print('\nPOINTS:')
    print(points_df)